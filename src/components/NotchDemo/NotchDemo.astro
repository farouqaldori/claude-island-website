---
import NotchPersistent from './NotchPersistent.astro';
import InstanceList from './InstanceList.astro';
import ChatView from './ChatView.astro';
---

<header id="notch" class="collapsed">
  <NotchPersistent />

  <div class="container">
    <div class="notch-popping"></div>

    <div class="notch-expanded">
      <InstanceList />
    </div>

    <ChatView />
  </div>
</header>

<style is:global>
  @import './notch.css';
</style>

<script>
  // ============================================================
  // SECTION 1: CONSTANTS & ENUMS
  // ============================================================

  const EventType = {
    USER_MESSAGE: 'userMessage',
    ASSISTANT_MESSAGE: 'assistantMessage',
    TOOL_USE: 'toolUse',
    TOOL_RESULT: 'toolResult',
    PERMISSION_REQUEST: 'permissionRequest',
    PERMISSION_APPROVED: 'permissionApproved',
    PERMISSION_DENIED: 'permissionDenied',
  };

  const ToolStatus = {
    RUNNING: 'running',
    WAITING_FOR_APPROVAL: 'waitingForApproval',
    SUCCESS: 'success',
    ERROR: 'error',
  };

  const InstanceState = {
    IDLE: 'idle',
    PROCESSING: 'processing',
    WAITING_FOR_APPROVAL: 'waitingForApproval',
    WAITING_FOR_INPUT: 'waitingForInput',
  };

  // ============================================================
  // SECTION 2: SESSION CLASS & STATE
  // ============================================================

  class Session {
    constructor(id, name) {
      this.id = id;
      this.name = name;
      this.state = InstanceState.IDLE;
      this.events = [];
      this.tools = new Map(); // toolId -> tool state
      this.pendingApproval = null; // { toolId, toolName, toolInput }
    }

    process(event) {
      // Don't add duplicate events
      const isDuplicate = this.events.some(e =>
        e.type === event.type &&
        e.toolId === event.toolId &&
        e.text === event.text
      );
      if (!isDuplicate) {
        this.events.push(event);
      }

      switch (event.type) {
        case EventType.USER_MESSAGE:
          this.state = InstanceState.PROCESSING;
          break;
        case EventType.ASSISTANT_MESSAGE:
          // Assistant responded, might be idle or continue processing
          break;
        case EventType.TOOL_USE:
          // Only add if not already exists
          if (!this.tools.has(event.toolId)) {
            this.tools.set(event.toolId, {
              id: event.toolId,
              name: event.toolName,
              input: event.toolInput,
              status: ToolStatus.RUNNING,
            });
          }
          this.state = InstanceState.PROCESSING;
          break;
        case EventType.PERMISSION_REQUEST:
          // Create or update tool with approval status
          const existingTool = this.tools.get(event.toolId) || {};
          this.tools.set(event.toolId, {
            id: event.toolId,
            name: event.toolName,
            input: event.toolInput,
            ...existingTool,
            status: ToolStatus.WAITING_FOR_APPROVAL,
          });
          this.pendingApproval = {
            toolId: event.toolId,
            toolName: event.toolName,
            toolInput: event.toolInput,
          };
          this.state = InstanceState.WAITING_FOR_APPROVAL;
          break;
        case EventType.PERMISSION_APPROVED:
          if (this.tools.has(event.toolId)) {
            this.tools.get(event.toolId).status = ToolStatus.RUNNING;
          }
          this.pendingApproval = null;
          this.state = InstanceState.PROCESSING;
          break;
        case EventType.PERMISSION_DENIED:
          if (this.tools.has(event.toolId)) {
            this.tools.get(event.toolId).status = ToolStatus.ERROR;
          }
          this.pendingApproval = null;
          this.state = InstanceState.WAITING_FOR_INPUT;
          break;
        case EventType.TOOL_RESULT:
          if (this.tools.has(event.toolId)) {
            this.tools.get(event.toolId).status = event.success ? ToolStatus.SUCCESS : ToolStatus.ERROR;
            this.tools.get(event.toolId).result = event.result;
          }
          break;
      }

      return this;
    }

    getChatHistory() {
      const items = [];
      // Track tool IDs we've seen to avoid duplicates
      const seenToolIds = new Set();

      for (const event of this.events) {
        switch (event.type) {
          case EventType.USER_MESSAGE:
            items.push({ type: 'user', text: event.text });
            break;
          case EventType.ASSISTANT_MESSAGE:
            items.push({ type: 'assistant', text: event.text });
            break;
          case EventType.TOOL_USE:
            // Only add each tool once, and skip if we'll see it as a permission request
            if (!seenToolIds.has(event.toolId)) {
              seenToolIds.add(event.toolId);
              const tool = this.tools.get(event.toolId);
              if (tool) {
                items.push({ type: 'tool', ...tool });
              }
            }
            break;
          case EventType.PERMISSION_REQUEST:
            // Permission requests are special tool entries - only add if not already seen
            if (!seenToolIds.has(event.toolId)) {
              seenToolIds.add(event.toolId);
              const tool = this.tools.get(event.toolId);
              if (tool) {
                items.push({ type: 'tool', ...tool });
              }
            }
            break;
        }
      }
      return items;
    }
  }

  // Sessions store
  const sessions = new Map();
  let activeSessionId = null;

  // Map terminal IDs to session IDs
  const terminalToSession = new Map();

  // ============================================================
  // SECTION 3: SESSION LIFECYCLE
  // ============================================================

  // Create a new session from terminal message
  function createSessionFromTerminal(terminalId: string, message: string) {
    const sessionId = `terminal-${terminalId}`;

    // If session already exists for this terminal, don't create a new one
    if (sessions.has(sessionId)) {
      return sessions.get(sessionId);
    }

    const session = new Session(sessionId, message);

    session.events.push({ type: EventType.USER_MESSAGE, text: message });
    session.state = InstanceState.PROCESSING;

    sessions.set(sessionId, session);
    terminalToSession.set(terminalId, sessionId);

    // Simulate processing and response
    simulateSessionResponse(sessionId, message);

    renderInstanceList();
    updateNotchState();

    return session;
  }

  // Add message to existing session
  function addMessageToSession(terminalId: string, message: string) {
    const sessionId = terminalToSession.get(terminalId);
    if (!sessionId) return;

    const session = sessions.get(sessionId);
    if (!session) return;

    session.events.push({ type: EventType.USER_MESSAGE, text: message });
    session.state = InstanceState.PROCESSING;

    if (activeSessionId === sessionId) {
      renderChat(sessionId);
    }
    renderInstanceList();
    updateNotchState();

    // For follow-up messages, use easter egg response
    simulateEasterEggResponse(session, sessionId);
  }

  // ============================================================
  // SECTION 4: SIMULATION RESPONSES
  // ============================================================

  // Track which sessions have already started simulation
  const simulationStarted = new Set<string>();

  // Helper to dispatch events to terminals
  function notifyTerminal(terminalId: string, eventType: string, data: any) {
    window.dispatchEvent(new CustomEvent('notchToTerminal', {
      detail: { terminalId, eventType, ...data }
    }));
  }

  // Get terminal ID from session ID
  function getTerminalIdFromSession(sessionId: string): string | null {
    if (sessionId.startsWith('terminal-')) {
      return sessionId.replace('terminal-', '');
    }
    return null;
  }

  // Simulate session based on terminal type
  function simulateSessionResponse(sessionId: string, message: string) {
    // Prevent duplicate simulations
    if (simulationStarted.has(sessionId)) return;
    simulationStarted.add(sessionId);

    const session = sessions.get(sessionId);
    if (!session) return;

    const lower = message.toLowerCase();

    // Terminal 3 (files) - just show tools, then wait for input
    if (lower.includes('file') || lower.includes('large') || lower.includes('find')) {
      simulateFilesSession(session, sessionId);
    } else if (lower.includes('react') || lower.includes('dashboard')) {
      // Terminal 1 - React: quick read, then permission comes from simulation
      simulateReactSession(session, sessionId);
    } else if (lower.includes('backend') || lower.includes('express') || lower.includes('server')) {
      // Terminal 2 - Backend: quick read, then permission comes from simulation
      simulateBackendSession(session, sessionId);
    } else {
      // Unrecognized message - use easter egg (fake LLM connection)
      simulateEasterEggResponse(session, sessionId);
    }
  }

  // Easter egg response for terminal - fake LLM connection attempts
  function simulateEasterEggResponse(session: Session, sessionId: string) {
    const terminalId = getTerminalIdFromSession(sessionId);
    const stage = easterEggStage.get(sessionId) || 0;
    const baseId = Date.now();

    function randomDelay(base: number, variance = 0.3) {
      return base * (1 + (Math.random() - 0.5) * variance * 2);
    }

    function runFailedConnections(count: number, baseDelay: number, onComplete: () => void, pauseBetween = 800) {
      let attempt = 0;
      function tryConnect() {
        attempt++;
        const toolId = `llm-connect-${baseId}-${attempt}`;
        session.process({
          type: EventType.TOOL_USE,
          toolId,
          toolName: 'Connect to LLM',
          toolInput: ''
        });
        if (terminalId) notifyTerminal(terminalId, 'toolUse', { toolName: 'Connect to LLM', toolInput: '' });
        renderInstanceList();
        if (activeSessionId === sessionId) renderChat(sessionId);

        const attemptDelay = randomDelay(baseDelay);
        setTimeout(() => {
          session.process({
            type: EventType.TOOL_RESULT,
            toolId,
            success: false
          });
          if (terminalId) notifyTerminal(terminalId, 'toolResult', { toolName: 'Connect to LLM', success: false });
          renderInstanceList();
          if (activeSessionId === sessionId) renderChat(sessionId);

          if (attempt < count) {
            setTimeout(tryConnect, randomDelay(pauseBetween));
          } else {
            setTimeout(onComplete, randomDelay(600));
          }
        }, attemptDelay);
      }
      tryConnect();
    }

    function sendMessage(msg: string) {
      session.process({ type: EventType.ASSISTANT_MESSAGE, text: msg });
      if (terminalId) notifyTerminal(terminalId, 'assistantMessage', { text: msg });
      session.state = InstanceState.WAITING_FOR_INPUT;
      renderInstanceList();
      if (activeSessionId === sessionId) renderChat(sessionId);
      updateNotchState();
    }

    // Run easter egg based on stage (delay to let user message appear first)
    const initialDelay = 400;
    switch (stage) {
      case 0:
        setTimeout(() => {
          runFailedConnections(3, 2500, () => {
            sendMessage("Um, so I'm just a demo, I'm not actually connected to an LLM. Sorry :)");
            easterEggStage.set(sessionId, 1);
          });
        }, initialDelay);
        break;
      case 1:
        setTimeout(() => {
          runFailedConnections(3, 1800, () => {
            sendMessage("Ok so I just retried connecting to an LLM, still failed :(");
            easterEggStage.set(sessionId, 2);
          }, 600);
        }, initialDelay);
        break;
      case 2:
        setTimeout(() => {
          runFailedConnections(3, 3500, () => {
            session.process({ type: EventType.ASSISTANT_MESSAGE, text: "Let me try again for real this time..." });
            if (terminalId) notifyTerminal(terminalId, 'assistantMessage', { text: "Let me try again for real this time..." });
            easterEggStage.set(sessionId, 3);
            renderInstanceList();
            if (activeSessionId === sessionId) renderChat(sessionId);

            setTimeout(() => {
              runFailedConnections(3, 2200, () => {
                sendMessage("Hmm... still didn't work. Shall we try again once more?");
              }, 900);
            }, randomDelay(1500));
          }, 1000);
        }, initialDelay);
        break;
      case 3:
        setTimeout(() => {
          session.process({ type: EventType.ASSISTANT_MESSAGE, text: "You're absolutely right! Let me give it another shot." });
          if (terminalId) notifyTerminal(terminalId, 'assistantMessage', { text: "You're absolutely right! Let me give it another shot." });
          renderInstanceList();
          if (activeSessionId === sessionId) renderChat(sessionId);

          setTimeout(() => {
            runFailedConnections(2, 2200, () => {
              sendMessage("It seemed like our connection was interrupted, can you repeat your last message?");
              easterEggStage.set(sessionId, 4);
            }, 700);
          }, randomDelay(800));
        }, initialDelay + randomDelay(1500));
        break;
      case 4:
        setTimeout(() => {
          sendMessage("I don't really know what you just wrote but would be really funny if you fell for it");
          easterEggStage.set(sessionId, 5);
        }, initialDelay + randomDelay(2500));
        break;
      default:
        setTimeout(() => {
          sendMessage("Ok I'm actually out of jokes now. This is just a demo website!");
          easterEggStage.set(sessionId, 0);
        }, initialDelay + randomDelay(1800));
        break;
    }
  }

  // React session: respond, then scan, then wait for permission
  function simulateReactSession(session: Session, sessionId: string) {
    const terminalId = getTerminalIdFromSession(sessionId);

    // Initial response
    const initialMessage = "I'll help you create a React dashboard. Let me check your project setup first.";
    setTimeout(() => {
      if (!sessions.has(sessionId)) return;
      session.process({ type: EventType.ASSISTANT_MESSAGE, text: initialMessage });
      if (terminalId) notifyTerminal(terminalId, 'assistantMessage', { text: initialMessage });
      if (activeSessionId === sessionId) renderChat(sessionId);
      renderInstanceList();
    }, 400);

    // Then run tools
    const tools = [
      { name: 'Read', input: 'package.json', delay: 1200, duration: 600 },
      { name: 'Glob', input: 'src/**/*.{js,jsx}', delay: 2200, duration: 500 },
    ];

    const baseTime = Date.now();

    tools.forEach((tool, index) => {
      const toolId = `tool-${baseTime}-${index}`;

      setTimeout(() => {
        if (!sessions.has(sessionId)) return;
        session.process({ type: EventType.TOOL_USE, toolId, toolName: tool.name, toolInput: tool.input });
        if (terminalId) notifyTerminal(terminalId, 'toolUse', { toolName: tool.name, toolInput: tool.input });
        if (activeSessionId === sessionId) renderChat(sessionId);
        renderInstanceList();
      }, tool.delay);

      setTimeout(() => {
        if (!sessions.has(sessionId)) return;
        session.process({ type: EventType.TOOL_RESULT, toolId, success: true });
        if (terminalId) notifyTerminal(terminalId, 'toolResult', { toolName: tool.name, success: true });
        if (activeSessionId === sessionId) renderChat(sessionId);
        renderInstanceList();
      }, tool.delay + tool.duration);
    });

    // Stay in processing - permission will come from simulation
  }

  // Backend session: respond, then scan, then wait for permission
  function simulateBackendSession(session: Session, sessionId: string) {
    const terminalId = getTerminalIdFromSession(sessionId);

    // Initial response
    const initialMessage = "I'll set up an Express backend for you. Let me check the current project structure.";
    setTimeout(() => {
      if (!sessions.has(sessionId)) return;
      session.process({ type: EventType.ASSISTANT_MESSAGE, text: initialMessage });
      if (terminalId) notifyTerminal(terminalId, 'assistantMessage', { text: initialMessage });
      if (activeSessionId === sessionId) renderChat(sessionId);
      renderInstanceList();
    }, 400);

    // Then run tools
    const tools = [
      { name: 'Read', input: 'package.json', delay: 1200, duration: 600 },
      { name: 'Glob', input: 'server/**/*.js', delay: 2200, duration: 500 },
    ];

    const baseTime = Date.now();

    tools.forEach((tool, index) => {
      const toolId = `tool-${baseTime}-${index}`;

      setTimeout(() => {
        if (!sessions.has(sessionId)) return;
        session.process({ type: EventType.TOOL_USE, toolId, toolName: tool.name, toolInput: tool.input });
        if (terminalId) notifyTerminal(terminalId, 'toolUse', { toolName: tool.name, toolInput: tool.input });
        if (activeSessionId === sessionId) renderChat(sessionId);
        renderInstanceList();
      }, tool.delay);

      setTimeout(() => {
        if (!sessions.has(sessionId)) return;
        session.process({ type: EventType.TOOL_RESULT, toolId, success: true });
        if (terminalId) notifyTerminal(terminalId, 'toolResult', { toolName: tool.name, success: true });
        if (activeSessionId === sessionId) renderChat(sessionId);
        renderInstanceList();
      }, tool.delay + tool.duration);
    });

    // Stay in processing - permission will come from simulation
  }

  // Cleanup response for files session (when user says "yes clean up")
  function simulateCleanupResponse(session: Session, sessionId: string) {
    const terminalId = getTerminalIdFromSession(sessionId);
    const tools = [
      { name: 'Bash', input: 'rm -rf .cache/ *.log', delay: 300, duration: 400 },
      { name: 'Bash', input: 'rm -rf node_modules/.cache', delay: 800, duration: 350 },
    ];

    const baseTime = Date.now();

    // Set to processing
    session.state = InstanceState.PROCESSING;
    renderInstanceList();
    updateNotchState();

    tools.forEach((tool, index) => {
      const toolId = `cleanup-${baseTime}-${index}`;

      setTimeout(() => {
        if (!sessions.has(sessionId)) return;
        session.process({ type: EventType.TOOL_USE, toolId, toolName: tool.name, toolInput: tool.input });
        if (terminalId) notifyTerminal(terminalId, 'toolUse', { toolName: tool.name, toolInput: tool.input });
        if (activeSessionId === sessionId) renderChat(sessionId);
        renderInstanceList();
      }, tool.delay);

      setTimeout(() => {
        if (!sessions.has(sessionId)) return;
        session.process({ type: EventType.TOOL_RESULT, toolId, success: true });
        if (terminalId) notifyTerminal(terminalId, 'toolResult', { toolName: tool.name, success: true });
        if (activeSessionId === sessionId) renderChat(sessionId);
        renderInstanceList();
      }, tool.delay + tool.duration);
    });

    // Final message
    const lastTool = tools[tools.length - 1];
    const finalMessage = "Done! I removed 847MB of cache and log files. Your disk should have more space now.";
    setTimeout(() => {
      if (!sessions.has(sessionId)) return;
      session.process({ type: EventType.ASSISTANT_MESSAGE, text: finalMessage });
      if (terminalId) notifyTerminal(terminalId, 'assistantMessage', { text: finalMessage });
      session.state = InstanceState.WAITING_FOR_INPUT;
      if (activeSessionId === sessionId) renderChat(sessionId);
      renderInstanceList();
      updateNotchState();

      // Signal that cleanup response is complete
      window.dispatchEvent(new CustomEvent('cleanupResponseComplete'));
    }, lastTool.delay + lastTool.duration + 200);
  }

  // Files session: respond, run tools, then wait for user input
  function simulateFilesSession(session: Session, sessionId: string) {
    const terminalId = getTerminalIdFromSession(sessionId);

    // Initial response
    const initialMessage = "I'll scan your system for large files. This might take a moment.";
    setTimeout(() => {
      if (!sessions.has(sessionId)) return;
      session.process({ type: EventType.ASSISTANT_MESSAGE, text: initialMessage });
      if (terminalId) notifyTerminal(terminalId, 'assistantMessage', { text: initialMessage });
      if (activeSessionId === sessionId) renderChat(sessionId);
      renderInstanceList();
    }, 400);

    // Then run tools (timed to finish AFTER Terminal 1 & 2 permissions are approved + collapsed ~18s into simulation)
    // Terminal 3 starts at ~6s into simulation, so tools should take ~20s
    const tools = [
      { name: 'Bash', input: 'du -sh * | sort -hr', delay: 4000, duration: 4500 },
      { name: 'Bash', input: 'find . -size +50M -type f', delay: 9500, duration: 5000 },
      { name: 'Glob', input: '**/*.{log,tmp,cache}', delay: 16000, duration: 3500 },
    ];

    const baseTime = Date.now();

    tools.forEach((tool, index) => {
      const toolId = `tool-${baseTime}-${index}`;

      setTimeout(() => {
        if (!sessions.has(sessionId)) return;
        session.process({ type: EventType.TOOL_USE, toolId, toolName: tool.name, toolInput: tool.input });
        if (terminalId) notifyTerminal(terminalId, 'toolUse', { toolName: tool.name, toolInput: tool.input });
        if (activeSessionId === sessionId) renderChat(sessionId);
        renderInstanceList();
      }, tool.delay);

      setTimeout(() => {
        if (!sessions.has(sessionId)) return;
        session.process({ type: EventType.TOOL_RESULT, toolId, success: true });
        if (terminalId) notifyTerminal(terminalId, 'toolResult', { toolName: tool.name, success: true });
        if (activeSessionId === sessionId) renderChat(sessionId);
        renderInstanceList();
      }, tool.delay + tool.duration);
    });

    // After tools, send assistant message and wait for input
    const lastTool = tools[tools.length - 1];
    const questionMessage = "I found several large files. The biggest ones are in node_modules and some log files. Would you like me to clean up the cache and log files?";
    setTimeout(() => {
      if (!sessions.has(sessionId)) return;
      session.process({ type: EventType.ASSISTANT_MESSAGE, text: questionMessage });
      if (terminalId) notifyTerminal(terminalId, 'assistantMessage', { text: questionMessage });
      session.state = InstanceState.WAITING_FOR_INPUT;
      if (activeSessionId === sessionId) renderChat(sessionId);
      renderInstanceList();
      updateNotchState();

      // Auto-expand notch when Terminal 3 asks for input
      if (viewMode === 'minimized') {
        setViewMode('expanded');
      }

      // Dispatch event for simulation to handle cursor response
      window.dispatchEvent(new CustomEvent('sessionWaitingForInput', {
        detail: { sessionId, terminalId: terminalId || '3' }
      }));
    }, lastTool.delay + lastTool.duration + 500);
  }

  // Run build tools after permission is approved (for react/backend)
  function runPostApprovalTools(session: Session, sessionId: string, type: 'react' | 'backend') {
    const terminalId = getTerminalIdFromSession(sessionId);
    const toolSets = {
      react: [
        { name: 'Write', input: 'src/components/Dashboard.jsx', delay: 400, duration: 300 },
        { name: 'Write', input: 'src/components/Sidebar.jsx', delay: 900, duration: 250 },
        { name: 'Write', input: 'src/App.css', delay: 1300, duration: 200 },
      ],
      backend: [
        { name: 'Write', input: 'server/index.js', delay: 400, duration: 300 },
        { name: 'Write', input: 'server/routes/api.js', delay: 850, duration: 250 },
        { name: 'Write', input: 'package.json', delay: 1200, duration: 150 },
      ]
    };

    const tools = toolSets[type];
    const baseTime = Date.now();

    tools.forEach((tool, index) => {
      const toolId = `post-${baseTime}-${index}`;

      setTimeout(() => {
        if (!sessions.has(sessionId)) return;
        session.process({ type: EventType.TOOL_USE, toolId, toolName: tool.name, toolInput: tool.input });
        if (terminalId) notifyTerminal(terminalId, 'toolUse', { toolName: tool.name, toolInput: tool.input });
        if (activeSessionId === sessionId) renderChat(sessionId);
        renderInstanceList();
      }, tool.delay);

      setTimeout(() => {
        if (!sessions.has(sessionId)) return;
        session.process({ type: EventType.TOOL_RESULT, toolId, success: true });
        if (terminalId) notifyTerminal(terminalId, 'toolResult', { toolName: tool.name, success: true });
        if (activeSessionId === sessionId) renderChat(sessionId);
        renderInstanceList();
      }, tool.delay + tool.duration);
    });

    // After tools complete, show completion message
    const lastTool = tools[tools.length - 1];
    const messages = {
      react: "Dashboard components created! Run `npm start` to see your new dashboard.",
      backend: "Backend server is set up! Run `npm run dev` to start the server."
    };
    setTimeout(() => {
      if (!sessions.has(sessionId)) return;
      session.process({ type: EventType.ASSISTANT_MESSAGE, text: messages[type] });
      if (terminalId) notifyTerminal(terminalId, 'assistantMessage', { text: messages[type] });
      session.state = InstanceState.WAITING_FOR_INPUT;
      if (activeSessionId === sessionId) renderChat(sessionId);
      renderInstanceList();
      updateNotchState();
    }, lastTool.delay + lastTool.duration + 200);
  }

  // ============================================================
  // SECTION 5: TERMINAL EVENT HANDLING
  // ============================================================

  // Listen for terminal messages
  window.addEventListener('terminalMessage', ((e: CustomEvent) => {
    const { terminalId, message, isFirst } = e.detail;

    if (isFirst) {
      createSessionFromTerminal(terminalId, message);
    } else {
      addMessageToSession(terminalId, message);
    }
  }) as EventListener);

  // Track which terminals have already received permission events
  const permissionTriggered = new Set<string>();

  // Trigger a permission request for a terminal's session
  function triggerPermissionForTerminal(terminalId: string, toolName: string, toolInput: string) {
    // Prevent duplicate permission triggers for same terminal
    if (permissionTriggered.has(terminalId)) return;
    permissionTriggered.add(terminalId);

    const sessionId = terminalToSession.get(terminalId);
    if (!sessionId) return;

    const session = sessions.get(sessionId);
    if (!session) return;

    // Don't add permission if session already has one pending
    if (session.state === InstanceState.WAITING_FOR_APPROVAL) return;

    const toolId = `perm-${terminalId}-${Date.now()}`;

    session.process({
      type: EventType.PERMISSION_REQUEST,
      toolId,
      toolName,
      toolInput
    });

    // Auto-expand notch when permission happens
    if (viewMode === 'minimized') {
      setViewMode('expanded');
    }

    if (activeSessionId === sessionId) {
      renderChat(sessionId);
    }
    renderInstanceList();
    updateNotchState();
  }

  // Listen for terminal permission events
  window.addEventListener('terminalPermission', ((e: CustomEvent) => {
    const { terminalId, toolName, toolInput } = e.detail;
    triggerPermissionForTerminal(terminalId, toolName, toolInput);
  }) as EventListener);

  // Expose function globally for simulation
  (window as any).triggerPermissionForTerminal = triggerPermissionForTerminal;

  // Initialize sessions (now empty - sessions come from terminals)
  function initSessions() {
    // Sessions are now created dynamically from terminal messages
    renderInstanceList();
  }

  // ============================================================
  // SECTION 6: SAMPLE SESSIONS (Post-Demo)
  // ============================================================

  // Create sample sessions after demo completes
  function createSampleSessions() {
    // 1. "How do I install Claude Island?" - starts IDLE, then PROCESSING
    const installSession = new Session('sample-install', 'How do I install Claude Island?');
    installSession.events.push({
      type: EventType.USER_MESSAGE,
      text: 'How do I install Claude Island?'
    });
    installSession.state = InstanceState.IDLE;
    sessions.set('sample-install', installSession);

    // After 1.5s, switch to PROCESSING (stays until user opens chat)
    setTimeout(() => {
      installSession.state = InstanceState.PROCESSING;
      renderInstanceList();
      updateNotchState();
    }, 1500);

    // 2. "Is Claude Island open-source?" - pre-loaded conversation with follow-ups
    const openSourceSession = new Session('sample-opensource', 'Is Claude Island open-source?');
    const osToolId = `opensource-${Date.now()}`;

    // First exchange: Is it open-source?
    openSourceSession.events.push({ type: EventType.USER_MESSAGE, text: 'Is Claude Island open-source?' });
    openSourceSession.events.push({ type: EventType.TOOL_USE, toolId: osToolId, toolName: 'Read', toolInput: 'LICENSE.md' });
    openSourceSession.tools.set(osToolId, { id: osToolId, name: 'Read', input: 'LICENSE.md', status: ToolStatus.SUCCESS });
    openSourceSession.events.push({ type: EventType.TOOL_RESULT, toolId: osToolId, success: true });
    openSourceSession.events.push({
      type: EventType.ASSISTANT_MESSAGE,
      text: "Yes! Claude Island is open-source under the Apache 2.0 license. You're free to use, modify, and distribute it."
    });

    // Second exchange: How can I contribute?
    openSourceSession.events.push({ type: EventType.USER_MESSAGE, text: 'How can I contribute?' });
    openSourceSession.events.push({
      type: EventType.ASSISTANT_MESSAGE,
      text: "We'd love your contributions! Feel free to:\n\n• Open a pull request\n• Submit issues for bugs or feature requests\n• Improve documentation\n\nCheck out the repo: https://github.com/farouqaldori/claude-island"
    });

    // Third exchange: I want to support this project
    openSourceSession.events.push({ type: EventType.USER_MESSAGE, text: 'I want to support this project' });
    openSourceSession.events.push({
      type: EventType.ASSISTANT_MESSAGE,
      text: "Thank you for your support! The best way to help is to star the repo on GitHub - it helps others discover Claude Island!\n\n⭐ https://github.com/farouqaldori/claude-island"
    });

    openSourceSession.state = InstanceState.IDLE;
    sessions.set('sample-opensource', openSourceSession);

    // 3. "Who built Claude Island?" - pre-loaded conversation
    const whoBuiltSession = new Session('sample-whobuilt', 'Who built Claude Island?');
    const wbToolId = `whobuilt-${Date.now()}`;
    whoBuiltSession.events.push({ type: EventType.USER_MESSAGE, text: 'Who built Claude Island?' });
    whoBuiltSession.events.push({ type: EventType.TOOL_USE, toolId: wbToolId, toolName: 'Bash', toolInput: 'git log --oneline -1' });
    whoBuiltSession.tools.set(wbToolId, { id: wbToolId, name: 'Bash', input: 'git log --oneline -1', status: ToolStatus.SUCCESS });
    whoBuiltSession.events.push({ type: EventType.TOOL_RESULT, toolId: wbToolId, success: true });
    whoBuiltSession.events.push({
      type: EventType.ASSISTANT_MESSAGE,
      text: "Claude Island was built by Farouq Aldori. You can follow him on X for updates!\n\nhttps://x.com/FarouqAldori"
    });
    whoBuiltSession.state = InstanceState.IDLE;
    sessions.set('sample-whobuilt', whoBuiltSession);
  }

  // Simulate the install response with multiple tool calls and permission request
  function simulateInstallResponse(sessionId: string) {
    const session = sessions.get(sessionId);
    if (!session) return;

    const baseTime = Date.now();

    // Tool sequence: Read -> Glob -> Read -> Permission request
    const tools = [
      { name: 'Read', input: 'README.md', delay: 0, duration: 600 },
      { name: 'Glob', input: 'releases/*.dmg', delay: 800, duration: 500 },
      { name: 'Read', input: 'INSTALL.md', delay: 1500, duration: 400 },
    ];

    // Run each tool in sequence
    tools.forEach((tool, index) => {
      const toolId = `install-${baseTime}-${index}`;

      setTimeout(() => {
        if (!sessions.has(sessionId)) return;
        session.process({
          type: EventType.TOOL_USE,
          toolId,
          toolName: tool.name,
          toolInput: tool.input
        });
        renderInstanceList();
        if (activeSessionId === sessionId) renderChat(sessionId);
      }, tool.delay);

      setTimeout(() => {
        if (!sessions.has(sessionId)) return;
        session.process({
          type: EventType.TOOL_RESULT,
          toolId,
          success: true
        });
        renderInstanceList();
        if (activeSessionId === sessionId) renderChat(sessionId);
      }, tool.delay + tool.duration);
    });

    // After all tools complete, request permission for "Send download link"
    const lastTool = tools[tools.length - 1];
    const permissionDelay = lastTool.delay + lastTool.duration + 300;

    setTimeout(() => {
      if (!sessions.has(sessionId)) return;
      const permToolId = `install-perm-${baseTime}`;

      session.process({
        type: EventType.PERMISSION_REQUEST,
        toolId: permToolId,
        toolName: 'Send download link',
        toolInput: 'github.com/anthropics/claude-island'
      });

      renderInstanceList();
      if (activeSessionId === sessionId) renderChat(sessionId);
      updateNotchState();
    }, permissionDelay);
  }

  // ============================================================
  // SECTION 7: USER INPUT HANDLING & EASTER EGGS
  // ============================================================

  // Track easter egg stage per session
  const easterEggStage = new Map(); // sessionId -> stage (0-5)

  // Handle user sending a message - simulates failed LLM connection with easter eggs
  function handleUserMessage(sessionId, text) {
    const session = sessions.get(sessionId);
    if (!session) return;

    const lower = text.toLowerCase();

    // Check if this is the simulated "clean up" response for files session
    if (lower.includes('clean') && (lower.includes('log') || lower.includes('yes'))) {
      // Add user message
      session.process({ type: EventType.USER_MESSAGE, text });
      renderChat(sessionId);
      renderInstanceList();

      // Simulate cleanup response
      simulateCleanupResponse(session, sessionId);
      return;
    }

    // Get current stage
    const stage = easterEggStage.get(sessionId) || 0;

    // Add user message
    session.process({ type: EventType.USER_MESSAGE, text });
    renderChat(sessionId);
    renderInstanceList();

    const baseId = Date.now();

    // Helper to add natural variance to timing
    function randomDelay(base, variance = 0.3) {
      return base * (1 + (Math.random() - 0.5) * variance * 2);
    }

    function runFailedConnections(count, baseDelay, onComplete, pauseBetween = 800) {
      let attempt = 0;
      function tryConnect() {
        attempt++;
        const toolId = `llm-connect-${baseId}-${attempt}`;
        session.process({
          type: EventType.TOOL_USE,
          toolId,
          toolName: 'Connect to LLM',
          toolInput: ''
        });
        renderChat(sessionId);
        renderInstanceList();

        // Vary the connection attempt time
        const attemptDelay = randomDelay(baseDelay);
        setTimeout(() => {
          session.process({
            type: EventType.TOOL_RESULT,
            toolId,
            success: false
          });
          renderChat(sessionId);
          renderInstanceList();

          if (attempt < count) {
            // Pause between retries with variance
            setTimeout(tryConnect, randomDelay(pauseBetween));
          } else {
            // Pause before callback
            setTimeout(onComplete, randomDelay(600));
          }
        }, attemptDelay);
      }
      tryConnect();
    }

    function runConnectionsWithLastSuccess(failCount, baseDelay, onComplete) {
      let attempt = 0;
      const totalAttempts = failCount + 1;
      function tryConnect() {
        attempt++;
        const toolId = `llm-connect-${baseId}-${attempt}`;
        session.process({
          type: EventType.TOOL_USE,
          toolId,
          toolName: 'Connect to LLM',
          toolInput: ''
        });
        renderChat(sessionId);
        renderInstanceList();

        // Last attempt takes longer (more suspenseful)
        const isLast = attempt === totalAttempts;
        const attemptDelay = isLast ? randomDelay(baseDelay * 1.5) : randomDelay(baseDelay);

        setTimeout(() => {
          session.process({
            type: EventType.TOOL_RESULT,
            toolId,
            success: isLast
          });
          renderChat(sessionId);
          renderInstanceList();

          if (!isLast) {
            setTimeout(tryConnect, randomDelay(700));
          } else {
            // Longer pause after success to let it sink in
            setTimeout(onComplete, randomDelay(1200));
          }
        }, attemptDelay);
      }
      tryConnect();
    }

    function sendMessage(msg) {
      session.process({ type: EventType.ASSISTANT_MESSAGE, text: msg });
      session.state = InstanceState.WAITING_FOR_INPUT;
      renderChat(sessionId);
      renderInstanceList();
    }

    switch (stage) {
      case 0:
        // First time: 3 failed connections, then demo message
        runFailedConnections(3, 2500, () => {
          sendMessage("Um, so I'm just a demo, I'm not actually connected to an LLM. Sorry :)");
          easterEggStage.set(sessionId, 1);
        });
        break;

      case 1:
        // Second time: 3 failed connections, retry message (slightly faster, we've seen this)
        runFailedConnections(3, 1800, () => {
          sendMessage("Ok so I just retried connecting to an LLM, still failed :(");
          easterEggStage.set(sessionId, 2);
        }, 600);
        break;

      case 2:
        // Third time: longer processing, then message (stay in processing) + 3 more failures
        runFailedConnections(3, 3500, () => {
          // Send message but stay in processing state
          session.process({ type: EventType.ASSISTANT_MESSAGE, text: "Let me try again for real this time..." });
          easterEggStage.set(sessionId, 3);
          renderChat(sessionId);
          renderInstanceList();

          // After message, do 3 more failed connections
          setTimeout(() => {
            const baseId2 = Date.now();
            let attempt2 = 0;
            function tryAgain() {
              attempt2++;
              const toolId = `llm-connect-${baseId2}-${attempt2}`;
              session.process({
                type: EventType.TOOL_USE,
                toolId,
                toolName: 'Connect to LLM',
                toolInput: ''
              });
              renderChat(sessionId);
              renderInstanceList();

              setTimeout(() => {
                session.process({
                  type: EventType.TOOL_RESULT,
                  toolId,
                  success: false
                });
                renderChat(sessionId);
                renderInstanceList();

                if (attempt2 < 3) {
                  setTimeout(tryAgain, randomDelay(900));
                } else {
                  setTimeout(() => {
                    sendMessage("Hmm... still didn't work. Shall we try again once more?");
                  }, randomDelay(800));
                }
              }, randomDelay(2200));
            }
            tryAgain();
          }, randomDelay(1500));
        }, 1000);
        break;

      case 3:
        // Fourth time: encouraging message after brief processing, then 2 failures then success
        setTimeout(() => {
          session.process({ type: EventType.ASSISTANT_MESSAGE, text: "You're absolutely right! Let me give it another shot." });
          renderChat(sessionId);

          setTimeout(() => {
            session.state = InstanceState.PROCESSING;
            renderChat(sessionId);
            renderInstanceList();

            setTimeout(() => {
              runConnectionsWithLastSuccess(2, 2200, () => {
                sendMessage("It seemed like our connection was interrupted, can you repeat your last message?");
                easterEggStage.set(sessionId, 4);
              });
            }, randomDelay(800));
          }, randomDelay(1000));
        }, randomDelay(1500));
        break;

      case 4:
        // Fifth time: the prank reveal - pause like thinking
        setTimeout(() => {
          sendMessage("I don't really know what you just wrote but would be really funny if you fell for it");
          easterEggStage.set(sessionId, 5);
        }, randomDelay(2500));
        break;

      default:
        // After all easter eggs, just loop back or stay idle
        setTimeout(() => {
          sendMessage("Ok I'm actually out of jokes now. This is just a demo website!");
          easterEggStage.set(sessionId, 0); // Reset for fun
        }, randomDelay(1800));
        break;
    }
  }

  // ============================================================
  // SECTION 8: RENDERING FUNCTIONS
  // ============================================================

  function renderChatMessages(session) {
    const container = document.getElementById('chat-messages');
    const history = session.getChatHistory();

    // Render in reverse for column-reverse layout
    container.innerHTML = history.slice().reverse().map(item => {
      switch (item.type) {
        case 'user':
          return `<div class="chat-message user">${escapeHtml(item.text)}</div>`;
        case 'assistant':
          return `<div class="chat-message assistant"><span>${linkify(item.text)}</span></div>`;
        case 'tool':
          const statusClass = {
            [ToolStatus.RUNNING]: 'running',
            [ToolStatus.WAITING_FOR_APPROVAL]: 'pending',
            [ToolStatus.SUCCESS]: 'success',
            [ToolStatus.ERROR]: 'error',
          }[item.status] || 'running';
          return `
            <div class="chat-tool">
              <span class="tool-dot ${statusClass}"></span>
              <span class="tool-name">${escapeHtml(item.name)}</span>
              <span class="tool-status">${escapeHtml(item.input || '')}</span>
            </div>`;
      }
      return '';
    }).join('');
  }

  // Track previous bottom bar state to avoid unnecessary animations
  let previousBottomBarState = null;

  function renderBottomBar(session) {
    const container = document.getElementById('chat-bottom-bar');

    // Determine current state type
    let currentState;
    if (session.state === InstanceState.WAITING_FOR_APPROVAL && session.pendingApproval) {
      currentState = 'approval';
    } else if (session.state === InstanceState.PROCESSING) {
      currentState = 'processing';
    } else {
      currentState = 'input';
    }

    // Only animate if state changed
    const shouldAnimate = previousBottomBarState !== null && previousBottomBarState !== currentState;
    previousBottomBarState = currentState;

    const animClass = shouldAnimate ? 'animate' : '';

    if (currentState === 'approval') {
      const { toolName, toolInput } = session.pendingApproval;
      container.innerHTML = `
        <div class="chat-approval-bar ${animClass}">
          <div class="approval-info">
            <div class="approval-tool-name">${escapeHtml(toolName)}</div>
            <div class="approval-tool-input">${escapeHtml(toolInput || '')}</div>
          </div>
          <button class="approval-btn deny">Deny</button>
          <button class="approval-btn allow">Allow</button>
        </div>`;

      // Attach event listeners
      container.querySelector('.allow').addEventListener('click', (e) => {
        e.stopPropagation();
        approvePermission(session.id);
      });
      container.querySelector('.deny').addEventListener('click', (e) => {
        e.stopPropagation();
        denyPermission(session.id);
      });
    } else if (currentState === 'processing') {
      container.innerHTML = `
        <div class="chat-processing ${animClass}">
          <span class="instance-spinner"></span>
          <span>Processing</span>
        </div>`;
    } else {
      container.innerHTML = `
        <div class="chat-input-bar ${animClass}">
          <input type="text" class="chat-input" placeholder="Message Claude...">
        </div>`;

      // Attach send handler and focus
      const input = container.querySelector('.chat-input');
      input.focus({ preventScroll: true });
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && input.value.trim()) {
          handleUserMessage(session.id, input.value.trim());
          input.value = '';
        }
      });
    }
  }

  function renderChat(sessionId) {
    const session = sessions.get(sessionId);
    if (!session) return;

    document.querySelector('.chat-title').textContent = session.name;
    renderChatMessages(session);
    renderBottomBar(session);
  }

  function renderInstanceList() {
    const list = document.querySelector('.instance-list');
    list.innerHTML = Array.from(sessions.values()).map(session => {
      let iconHtml, statusText, statusClass;
      let hasApprovalButtons = false;
      let approvalToolName = '';

      switch (session.state) {
        case InstanceState.WAITING_FOR_INPUT:
          iconHtml = `<span class="instance-dot waiting-input"></span>`;
          statusText = 'Waiting for input';
          statusClass = 'waiting-input';
          break;
        case InstanceState.WAITING_FOR_APPROVAL:
          iconHtml = `<div class="instance-icon approval">
            <svg viewBox="0 0 30 30" fill="none">
              <rect x="5" y="5" width="4" height="4" fill="#ffb340"/>
              <rect x="5" y="9" width="4" height="4" fill="#ffb340"/>
              <rect x="9" y="1" width="4" height="4" fill="#ffb340"/>
              <rect x="13" y="1" width="4" height="4" fill="#ffb340"/>
              <rect x="17" y="1" width="4" height="4" fill="#ffb340"/>
              <rect x="21" y="5" width="4" height="4" fill="#ffb340"/>
              <rect x="21" y="9" width="4" height="4" fill="#ffb340"/>
              <rect x="13" y="17" width="4" height="4" fill="#ffb340"/>
              <rect x="13" y="25" width="4" height="4" fill="#ffb340"/>
              <rect x="17" y="13" width="4" height="4" fill="#ffb340"/>
            </svg>
          </div>`;
          hasApprovalButtons = true;
          approvalToolName = session.pendingApproval?.toolName || 'Tool';
          statusText = approvalToolName;
          statusClass = 'approval';
          break;
        case InstanceState.PROCESSING:
          iconHtml = `<span class="instance-spinner"></span>`;
          statusText = 'Processing';
          statusClass = 'processing';
          break;
        default:
          iconHtml = `<span class="instance-dot idle"></span>`;
          statusText = 'Idle';
          statusClass = '';
      }

      if (hasApprovalButtons) {
        return `
          <div class="instance-item instance-item-approval" data-session="${session.id}">
            ${iconHtml}
            <div class="instance-info">
              <div class="instance-name">${escapeHtml(session.name)}</div>
              <div class="instance-status ${statusClass}">${statusText}</div>
            </div>
            <div class="instance-approval-buttons">
              <button class="approval-btn deny instance-btn-deny" data-session="${session.id}">Deny</button>
              <button class="approval-btn allow instance-btn-approve" data-session="${session.id}">Allow</button>
            </div>
          </div>`;
      }

      return `
        <div class="instance-item" data-session="${session.id}">
          ${iconHtml}
          <div class="instance-info">
            <div class="instance-name">${escapeHtml(session.name)}</div>
            <div class="instance-status ${statusClass}">${statusText}</div>
          </div>
          <span class="instance-arrow">›</span>
        </div>`;
    }).join('');

    // Re-attach click listeners for regular items
    document.querySelectorAll('.instance-item:not(.instance-item-approval)').forEach(item => {
      item.addEventListener('click', (e) => {
        e.stopPropagation();
        const sessionId = item.dataset.session;
        activeSessionId = sessionId;
        renderChat(sessionId);
        setViewMode('chat');

        // If this is the install session in PROCESSING state, trigger the response
        const session = sessions.get(sessionId);
        if (sessionId === 'sample-install' && session?.state === InstanceState.PROCESSING) {
          simulateInstallResponse(sessionId);
        }
      });
    });

    // Attach approve/deny button listeners
    document.querySelectorAll('.instance-btn-approve').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const sessionId = btn.dataset.session;
        approvePermission(sessionId);
      });
    });

    document.querySelectorAll('.instance-btn-deny').forEach(btn => {
      btn.addEventListener('click', (e) => {
        e.stopPropagation();
        const sessionId = btn.dataset.session;
        denyPermission(sessionId);
      });
    });

    // Update notch state based on session activity
    updateNotchState();
  }

  // ============================================================
  // SECTION 9: PERMISSION HANDLING
  // ============================================================

  function approvePermission(sessionId) {
    const session = sessions.get(sessionId);
    if (!session || !session.pendingApproval) return;

    const toolId = session.pendingApproval.toolId;
    const toolName = session.pendingApproval.toolName;
    const toolInput = session.pendingApproval.toolInput || '';
    session.process({ type: EventType.PERMISSION_APPROVED, toolId });

    renderChat(sessionId);
    renderInstanceList();

    // Simulate tool completion after delay
    setTimeout(() => {
      session.process({ type: EventType.TOOL_RESULT, toolId, success: true });

      if (activeSessionId === sessionId) {
        renderChat(sessionId);
      }
      renderInstanceList();

      // Handle specific demo cases
      if (toolName === 'Send download link') {
        // Show the download link message
        setTimeout(() => {
          session.process({
            type: EventType.ASSISTANT_MESSAGE,
            text: "Here's the download link: https://github.com/anthropics/claude-island/releases\n\nJust download the .dmg file and drag Claude Island to your Applications folder!"
          });
          session.state = InstanceState.WAITING_FOR_INPUT;

          if (activeSessionId === sessionId) {
            renderChat(sessionId);
          }
          renderInstanceList();
        }, 800);
      } else if (toolInput.includes('create-react-app') || toolInput.includes('react')) {
        // React project - run build tools
        setTimeout(() => {
          runPostApprovalTools(session, sessionId, 'react');
        }, 300);
      } else if (toolInput.includes('npm init') || toolInput.includes('express')) {
        // Backend project - run build tools
        setTimeout(() => {
          runPostApprovalTools(session, sessionId, 'backend');
        }, 300);
      } else {
        // Default: just mark as waiting for input
        setTimeout(() => {
          session.state = InstanceState.WAITING_FOR_INPUT;
          if (activeSessionId === sessionId) {
            renderChat(sessionId);
          }
          renderInstanceList();
        }, 500);
      }
    }, 800);
  }

  function denyPermission(sessionId) {
    const session = sessions.get(sessionId);
    if (!session || !session.pendingApproval) return;

    const toolId = session.pendingApproval.toolId;
    session.process({ type: EventType.PERMISSION_DENIED, toolId });

    renderChat(sessionId);
    renderInstanceList();
  }

  // ============================================================
  // SECTION 10: UTILITY FUNCTIONS
  // ============================================================

  function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
  }

  function formatMarkdown(text) {
    // First escape HTML
    let result = escapeHtml(text);

    // Convert URLs to links
    const urlRegex = /(https?:\/\/[^\s]+)/g;
    result = result.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener noreferrer">$1</a>');

    // Convert bullet points (• or - at start of line)
    result = result.replace(/^[•\-]\s+(.*)$/gm, '<span class="md-bullet">•</span> $1');

    // Convert numbered lists (1. 2. etc at start of line)
    result = result.replace(/^(\d+)\.\s+(.*)$/gm, '<span class="md-number">$1.</span> $2');

    // Convert newlines to <br> tags
    result = result.replace(/\n/g, '<br>');

    return result;
  }

  // Alias for backward compatibility
  function linkify(text) {
    return formatMarkdown(text);
  }

  // ============================================================
  // SECTION 11: UI STATE & ANIMATION
  // ============================================================

  const symbols = ['·', '✢', '✳', '∗', '✻', '✽'];
  let phase = 0;
  setInterval(() => {
    phase = (phase + 1) % symbols.length;
    document.querySelectorAll('.processing-spinner, .instance-spinner').forEach(s => {
      s.textContent = symbols[phase];
    });
  }, 150);

  const notch = document.getElementById('notch');
  let animationTimeout = null;

  // View mode: where the user is in the UI
  // 'minimized' = collapsed area (will show as collapsed or popping based on activity)
  // 'expanded' = session list view
  // 'chat' = chat view with a specific session
  let viewMode = 'minimized';

  // Check if any session is active (processing or waiting for approval)
  function hasActiveSession() {
    for (const session of sessions.values()) {
      if (session.state === InstanceState.PROCESSING ||
          session.state === InstanceState.WAITING_FOR_APPROVAL) {
        return true;
      }
    }
    return false;
  }

  // Derive the CSS class from view mode + session activity
  function deriveNotchClass() {
    const isActive = hasActiveSession();

    switch (viewMode) {
      case 'minimized':
        // Minimized view shows popping if active, collapsed if not
        return isActive ? 'popping' : 'collapsed';
      case 'expanded':
        // Expanded shows session list, add 'inactive' modifier if no activity
        return isActive ? 'expanded' : 'expanded inactive';
      case 'chat':
        // Chat view, add 'inactive' modifier if no activity
        return isActive ? 'chat' : 'chat inactive';
      default:
        return 'collapsed';
    }
  }

  // Apply the derived state to the notch
  function updateNotchState() {
    const newClass = deriveNotchClass();
    if (notch.className === newClass) return;

    notch.style.willChange = 'width, height, border-radius';
    notch.className = newClass;

    clearTimeout(animationTimeout);
    animationTimeout = setTimeout(() => {
      notch.style.willChange = 'auto';
    }, 550);
  }

  // Set view mode and update notch
  function setViewMode(mode) {
    viewMode = mode;
    updateNotchState();
  }

  // ============================================================
  // SECTION 12: EVENT LISTENERS
  // ============================================================

  // Disabled state - wait for simulation to complete
  let demoEnabled = false;

  // Listen for simulation complete event
  window.addEventListener('simulationComplete', () => {
    demoEnabled = true;

    // Clean up demo instances (terminal sessions)
    for (const sessionId of sessions.keys()) {
      if (sessionId.startsWith('terminal-')) {
        sessions.delete(sessionId);
      }
    }

    // Close the mail client
    window.dispatchEvent(new CustomEvent('closeEmail'));

    // Create sample sessions
    createSampleSessions();
    renderInstanceList();
    updateNotchState();
  });

  // Click on notch (minimized area) to expand
  notch.addEventListener('click', (e) => {
    if (!demoEnabled) return;
    if (viewMode === 'minimized') {
      setViewMode('expanded');
    }
  });

  // Chat back button -> back to expanded
  document.getElementById('chat-back').addEventListener('click', (e) => {
    if (!demoEnabled) return;
    e.stopPropagation();
    setViewMode('expanded');
  });

  // Click outside to minimize
  document.addEventListener('click', (e) => {
    if (!demoEnabled) return;
    if (!notch.contains(e.target)) {
      if (viewMode === 'expanded' || viewMode === 'chat') {
        setViewMode('minimized');
      }
    }
  });

  // Listen for collapse event from simulation
  window.addEventListener('collapseNotch', () => {
    setViewMode('minimized');
  });

  // Listen for expand event from simulation
  window.addEventListener('expandNotch', () => {
    setViewMode('expanded');
  });

  // Listen for open session chat event from simulation
  window.addEventListener('openSessionChat', ((e: CustomEvent) => {
    const { sessionId } = e.detail;
    activeSessionId = sessionId;
    renderChat(sessionId);
    setViewMode('chat');
  }) as EventListener);

  // Listen for reset event (when demo is stopped)
  window.addEventListener('resetNotch', () => {
    // Clear all sessions
    sessions.clear();
    activeSessionId = null;

    // Reset demo state
    demoEnabled = false;
    terminalToSession.clear();
    permissionTriggered.clear();
    easterEggStage.clear();

    // Reset to minimized view
    setViewMode('minimized');

    // Clear instance list UI
    const instanceList = document.querySelector('.instance-list');
    if (instanceList) instanceList.innerHTML = '';

    // Clear chat UI
    const chatMessages = document.querySelector('.chat-messages');
    if (chatMessages) chatMessages.innerHTML = '';

    // Reset notch classes
    notch?.classList.remove('has-sessions', 'inactive', 'has-permission');
  });
</script>
